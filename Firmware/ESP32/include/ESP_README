
This directory is intended for project header files.

A header file is a file containing C declarations and macro definitions
to be shared between several project source files. You request the use of a
header file in your project source file (C, C++, etc) located in `src` folder
by including it, with the C preprocessing directive `#include'.

```src/main.c

#include "header.h"

int main (void)
{
 ...
}
```

Including a header file produces the same results as copying the header file
into each source file that needs it. Such copying would be time-consuming
and error-prone. With a header file, the related declarations appear
in only one place. If they need to be changed, they can be changed in one
place, and programs that include the header file will automatically use the
new version when next recompiled. The header file eliminates the labor of
finding and changing all the copies as well as the risk that a failure to
find one copy will result in inconsistencies within a program.

In C, the convention is to give header files names that end with `.h'.

Read more about using header files in official GCC documentation:

* Include Syntax
* Include Operation
* Once-Only Headers
* Computed Includes

https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html


UNUSED CODE:

#include <Arduino.h>
#include <Wire.h>
#include <VL53L0X.h>

// UPDATE - FOLLOWING CODE RELIED ON ONLY TOF USAGE; NEW IDEA REQUIRES IMU SO I WILL DISCARD THE FOLLOWING
// VL53L0X distance sensor object

/*

VL53L0X tof;

// Preparing constants
// closest finger position from sensor to fingertip
const float MIN_DISTANCE_MM = 40.0f;
// farthest finger position
const float MAX_DISTANCE_MM = 120.0f;
// amount of virtual frets
const int NUM_FRETS = 8;

// guitar neck scale 25.5" strat
const float SCALE_LENGTH_MM = 648.0f;

// Smoothing factor
const float ALPHA = 0.3f;

// how long a fret must be the same to consider it
const int STABLE_COUNT = 3;

// Low E string
const int BASE_MIDI_E2 = 40;

// note names
const char* noteNames[] = {
  "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
};

// boundaries for each fret
float fretBoundaries[NUM_FRETS + 1];

// compute from real guitar to arm distance
void computeFretBoundaries(){
  float pos[NUM_FRETS + 1] = {0.f};
  for (int n=1; n<=NUM_FRETS; n++){
    float xn = SCALE_LENGTH_MM * (1.0f - powf(2.0f, -n / 12.0f));
    pos[n] = xn / SCALE_LENGTH_MM;
  }

  // map to distance from sensor
  float armSpan = MAX_DISTANCE_MM - MIN_DISTANCE_MM;
  float d[NUM_FRETS + 1];

  d[0] = MIN_DISTANCE_MM; // open string
  for (int n=1; n<=NUM_FRETS; n++){
    d[n] = MIN_DISTANCE_MM + pos[n] * armSpan;
  }

  // boundaries: midpoints between neighboring frets
  // boundary[k] is where we switch from fret k to k+1
  fretBoundaries[0] = MIN_DISTANCE_MM - 100.0f;  // anything smaller is treated as "too close"
  for (int k = 1; k < NUM_FRETS; ++k) {
    fretBoundaries[k] = 0.5f * (d[k] + d[k+1]);
  }
  fretBoundaries[NUM_FRETS] = MAX_DISTANCE_MM + 100.0f; // safety margin
}

// Mapping distance to fret number
int distanceToFret(float d_mm) {
  if (d_mm < MIN_DISTANCE_MM || d_mm > MAX_DISTANCE_MM) {
    return 0; // out of range
  }

  /* size of each fret zone 
  float zone = span / NUM_FRETS;
  // distance from start of fret
  float rel = d_mm - MIN_DISTANCE_MM;
  // approximate fret
  int fret = (int)(rel / zone) + 1;

  if (fret < 1) fret = 1;
  if (fret > NUM_FRETS) fret = NUM_FRETS;
  return fret;
  


// changed from previous version to use boundaries
 for (int fret = 1; fret <= NUM_FRETS; ++fret) {
    if (d_mm <= fretBoundaries[fret]) {
      return fret;
    }
  }
  return NUM_FRETS;
}

// Setting up I2C pins for ESP32
// REMEMBER - DRIVER MIGHT BE NEEDED FOR ESP32 RECOGNITION
// https://www.silabs.com/software-and-tools/usb-to-uart-bridge-vcp-drivers

void setup() {
  Serial.begin(115200);
  delay(1000);

  Wire.begin(21, 22);
  delay(100);

  // different esp32 boards
  // Wire.begin(8, 9) - S3
  // Wire.begin(21, 22) - Wroom

  Serial.println("initializing VL53L0X Test");

  // check if sensor works
  if (!tof.init()) {
    Serial.println("VL53L0X init failed. Check wiring/power.");
    while (1) delay(100);
  }
  tof.setTimeout(500);
  Serial.println("VL53L0X OK.");

  computeFretBoundaries();
}

// Main loop to read distance
void loop() {
  uint16_t mm = tof.readRangeSingleMillimeters();
  
  if (tof.timeoutOccurred()) {
    Serial.println("Timeout");
    delay(100);
    return;
  } 
  
  static float filtered = -1.0f;
  if (filtered < 0){
    filtered = mm;
  } else {
    filtered = ALPHA * mm + (1.0f - ALPHA) * filtered;
  }
  
  int fret = distanceToFret(filtered);

  // filter on stable fret
  static int lastFret = 0;
  static int stableFret = 0;
  static int sameCount = 0;

  if (fret == lastFret) {
    sameCount++;
  } else {
    sameCount = 1;
    lastFret = fret; 
  }

  if (sameCount >= STABLE_COUNT) {
    stableFret = fret;
  }

  int midiNote;
  const char* noteName;
  if (stableFret == 0) {
    midiNote = BASE_MIDI_E2;          // open string
  } else {
    midiNote = BASE_MIDI_E2 + stableFret;
  }
  
  int noteIndex = (midiNote % 12 + 12) % 12; // ensure positive index
  noteName = noteNames[noteIndex];

  // print every few frames so its readable
  static int printCounter = 0;
  printCounter++;
  if (printCounter % 5 == 0){
    Serial.printf("fret=%4u  filt=%6.1f mm  rawFret=%d  fret=%d  note=%s (MIDI %d)\n",
                  fret, filtered, lastFret, stableFret, noteName, midiNote);
  }
  //change delay as needed
  delay(20);
}

*/


// new code to check dupont merged wires

/*
#include <Wire.h>

void setup() {
  Wire.begin(21, 22); // SDA, SCL
  Serial.begin(115200);
  delay(1000);
  Serial.println("I2C Scanner");
}

void loop() {
  byte error, address;
  int nDevices = 0;

  for (address = 1; address < 127; address++ ) {
    Wire.beginTransmission(address);
    error = Wire.endTransmission();

    if (error == 0) {
      Serial.print("I2C device found at 0x");
      Serial.println(address, HEX);
      nDevices++;
    }
  }

  if (nDevices == 0) Serial.println("No I2C devices found");
  else Serial.println("Scan complete");

  delay(2000);
}

*/

#include <Arduino.h>
#include <Wire.h>
#include <VL53L0X.h>

VL53L0X tof;

// I2C address for MPU6500 (verify from scanner: 0x68 or 0x69)
const uint8_t MPU_ADDR = 0x68;

// --- I2C helpers for MPU ---
uint8_t mpuRead8(uint8_t reg) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(reg);
  Wire.endTransmission(false);   // repeated start
  Wire.requestFrom(MPU_ADDR, (uint8_t)1);
  if (Wire.available()) {
    return Wire.read();
  }
  return 0;
}

void mpuWrite8(uint8_t reg, uint8_t value) {
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(reg);
  Wire.write(value);
  Wire.endTransmission();
}

// init MPU6500: wake + basic accel config
bool mpuInit() {
  uint8_t whoami = mpuRead8(0x75);   // WHO_AM_I

  Serial.print("MPU WHO_AM_I = 0x");
  Serial.println(whoami, HEX);

  // for 6500 this should be something like 0x70 (varies by variant)
  if (whoami == 0x00 || whoami == 0xFF) {
    return false;  // clearly broken bus
  }

  // Wake up device (clear sleep bit)
  mpuWrite8(0x6B, 0x00);  // PWR_MGMT_1 = 0
  delay(100);

  // Optional: accel ±2g (ACCEL_CONFIG = 0)
  mpuWrite8(0x1C, 0x00);
  // Optional: gyro config default

  return true;
}

// read raw accel and convert to m/s^2
void mpuReadAccel(float &ax, float &ay, float &az) {
  // ACCEL_XOUT_H = 0x3B
  Wire.beginTransmission(MPU_ADDR);
  Wire.write(0x3B);
  Wire.endTransmission(false);
  Wire.requestFrom(MPU_ADDR, (uint8_t)6);

  int16_t rawX = (Wire.read() << 8) | Wire.read();
  int16_t rawY = (Wire.read() << 8) | Wire.read();
  int16_t rawZ = (Wire.read() << 8) | Wire.read();

  // For ±2g, sensitivity ≈ 16384 LSB/g
  const float scale = 9.80665f / 16384.0f; // m/s^2 per LSB

  ax = rawX * scale;
  ay = rawY * scale;
  az = rawZ * scale;
}

void setup() {
  Serial.begin(115200);
  delay(1000);

  Wire.begin(21, 22);   // SDA, SCL

  // --- ToF init ---
  if (!tof.init()) {
    Serial.println("VL53L0X init failed");
    while (1) delay(100);
  }
  tof.setTimeout(500);
  Serial.println("VL53L0X OK");

  // --- MPU6500 init ---
  if (!mpuInit()) {
    Serial.println("MPU6500 init failed (bad WHO_AM_I or wiring)");
    while (1) delay(500);
  }
  Serial.println("MPU6500 OK");
}

void loop() {
  // Distance
  uint16_t d = tof.readRangeSingleMillimeters();
  if (tof.timeoutOccurred()) {
    Serial.println("ToF timeout");
    return;
  }

  // Accel
  float ax, ay, az;
  mpuReadAccel(ax, ay, az);

  // Compute simple roll/pitch from accel
  float roll  = atan2(ay, az) * 180.0f / PI;
  float pitch = atan2(-ax, sqrtf(ay*ay + az*az)) * 180.0f / PI;

  Serial.printf("dist=%4u mm  |  ax=%6.2f ay=%6.2f az=%6.2f  |  roll=%6.1f pitch=%6.1f\n",
                d, ax, ay, az, roll, pitch);

  delay(1000);
}
